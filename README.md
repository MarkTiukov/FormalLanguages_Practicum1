# FormalLanguages_Practicum1
Первый практикум по курсу "Формальные языки и трансляции", МФТИ ФПМИ ПМИ, 2 курс

## Общая задача

Нужно реализовать некоторый алгоритм обработки регулярных выражений. В каждой задаче аргументами являются 
строка в алфавите {a, b, c, 1, ., +, ∗}, а также некоторые дополнительные параметры.
Если задача предполагает ответ “да/нет”, то необходимо вывести yes в случае положительного ответа
и no — в случае отрицательного. В случае, если ответ является
целым числом или словом, необходимо вывести это число или слово. В случае, если
таких числа или слова не существует, необходимо вывести INF. В случае, если входная строка не является
корректным регулярным выражением в обратной польской
записи, необходимо выдать сообщение error об ошибке. Дополнительные случаи
оговорены непосредственно при формулировке задачи.
В дальнейшем предполагается, что первым компонентом входа является регулярное
выражение α в обратной польской записи, задающее язык L.

## Конкретная задача
Даны α и слово u \in {a,b,c}*
Найти длину самого длинного суффикса u,
являющегося также суффиксом некоторого слова в L.

## Описание алгоритма решения
1. Обрабатываем регулярное выражение, используя стек: для каждой операции определяем её аргументы (если при обходе встретили знак операции, то достаем со стека нужное количество аргументов и кладем новое "выражение" типа _MyExpression_). То есть получается один большой объект, состоящий из объектов того же класса (_MyExpression_), каждый объект знает свою операцию и свой аргумент(ы). 
1. Рекурсивно обрабатываем полученный на предыдущем шаге объект. Оработка возвращает пару списков: в первом содержатся длины всех возможных префиксов переданного на обработку слова, которые являются префиксом некоторого слова в данном выражении; во втором хранятся булевские переменные, соответствующие числам из первого списка, каждая переменная показывает, можно ли что-то добавить к соответствующему префиксу. 
1. Берем максимум от полученного в качестве первого аргумента списка чисел

### Как обрабатывать каждую операцию:

- '+' (сложение/или)

  Результатом является обычное объединение рузльтатов левого и правых аргументов от того же слова
  
- '*' (звезда Клини)

  Результатом `e*`, где _e_ -- некоторый объект типа _MyExpression_ является пара `(0, True)` и результат конкатенации `e.e*` с тем же словом
  
- '.' (конкатенация)

  Чтобы получить результат конкатенации, необходимо к каждому частному результату левой части (то есть каждый элемент списка, возвращаемого обработкой левой части) прибавить результаты, полученные от правой части со словом без уже определенного префикса. То есть если рассматривать слово `word`, а `res_i` -- iый элемент результата левой части при обработки этого слова, то к `res_i` надо прибавить значения результата обработки правого аргумента с подсловом `word` от `res_i` символа. Конечно же, при условии, что соответствующая `res_i` булевская переменная принимает значение `True` (иначе результатом будет просто `res_i`. 

## Запуск

Для запускать программы необходимо запустить через Python файл __main.py__ 

Пример для запуска на macos и Linux (из корневой папки)

```$ python3 main.py```

### Входные данные

На первой строчке вводится слово, на второй регулярное выражение в обратной польской записи (сначала идет левый аргумент, потом правый). Регулярное выражение может содержать символы алфавита, пустой символ ('1'), и символы операций ('+', '*', '.'). 

#### Пример входных данных:

```
abacb
ab+c.aba.*.bac.+.+*
```

### Выходные данные 

Выводится одно число -- максимальный префикс данного слова, который содержится в некотором слове данного регулярного выражения. 

## Тестирование
В модуле __main_test.py__ реализовано юнит-тестирование с покрытием __main.py__ в 97%
  
### Запуск тестирования с покрытием

#### установка `coverage`

```
pip install coverage
```

### Запуск

```
coverage run tests.py
```

### Генерация репорта (в формате html)

```
coverage html
```

(репорт создается в папке `htmlcov`)
